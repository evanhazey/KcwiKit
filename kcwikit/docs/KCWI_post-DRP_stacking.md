# KCWI Post-DRP Stacking Instructions

This instruction provides a step-by-step guide on how to spatially register, stack, individual cubes produced by the KCWI DRP, and perform astrometric corrections. 

An example Jupyter notebook, as well as the necessary files to run this tool, is provided in the [examples](../examples/) directory. 

# Preparations

Overview:
1. All frames need to be reduced by the `KCWI_DRP`, at least after the DAR correction (`icubed.fits`), but ideally after the flux calibration (`icubes.fits`). 
2. For each field, an `<object_name>.list` file specifying the input cubes to be used to make the stack.
3. An `<object_name>.par` file with a list of arguments and parameters for the particular stack.
4. A `<object_name>.ipynb` `jupyter` notebook in which to run the stacking routine. This could be substituted for a `python` script in one so desires.

## Input FITS files

The input files nominally come in two flavors:
- `kb*_icubes.fits` and `kr*_icubes.fits` if flux calibrated **OR**
- `kb*_icubed.fits` and `kr*_icubed.fits` if making a quick stack while observing.

## The `.list`  File

A sample `.list` file is provided [here](../examples/q2343-BX610.list) and the first few lines are displayed here for convenience.

```
/scr/yuguangchen/obs/kcwi/kcwi_nov19/2019nov29/redux/kb191129_00041 3 3
/scr/yuguangchen/obs/kcwi/kcwi_nov19/2019nov29/redux/kb191129_00040 3 3
/scr/yuguangchen/obs/kcwi/kcwi_nov19/2019nov29/redux/kb191129_00042 3 3
/scr/yuguangchen/obs/kcwi/kcwi_nov19/2019nov29/redux/kb191129_00043 3 3
/scr/yuguangchen/obs/kcwi/kcwi_nov19/2019nov29/redux/kb191129_00044 3 3
```

Note that the full path of each file is required and trailing extension (e.g. `_icubes.fits`) is provided here. The second and third columns list the number of pixels to be trimmed from the bottom and top of each input cube, thus removing some bad edge pixels. 

In other words, the line `kb230105_00056 2 5` would remove two pixels from the bottom of the cube and five pixels from the top (for all wavelengths). These pixels correspond to slice edge rolloff in the 2D (detector) format. This clipping only applies to the "data-region" of the cube. The zeros padding from the DAR correction would be automatically removed, and not included in the counting of pixels here.

We have found three pixel top and bottom clipping to work well for the Medium slicer, low resolution grating, 2x2 binning setup but your mileage may vary. You can check if the trimming needs to be adjust later by opening the `kcwi_align/*thum0.fits` file after it is generated by the `kcwi_align` procedure (see below).

Here's a simple command that can be used to produce sequential lists of cubes in the correct format: `printf "%s\n" /path/to/dir/2021aug13/redux/kb210811_000{26..34}\ 3\ 3`.

## The `.par`  File

The parameter file takes in a list of options used while stacking and to define the output stack (e.g. final stack dimensions, pixel scales, reference astrometry images, etc.).

Here is [A complete reference of the parameter file](./parameter_file_reference.md). Typically, only a small fraction of the parameters are necessary. Here is a [sample parameter file](../examples/q2343-BX610.par), which is also displayed here.

```
dimension 100 100
align_box 45 37 65 65 
orientation 0
xpix 0.3
ypix 0.3
ref_xy 51 52
ref_ad 356.53929 12.822
ref_fn /scr/yuguangchen/obs/kcwi/plan/q2343/q2343Rs.fits
```

For a basic stack without a final WCS adjustment (skipping `kcwi_astrometry`), one can omit the `ref_*` lines.

Each of these parameters correspond to arguments in the `kcwi_align`, `kcwi_stack`, or `kcwi_astrometry` functions and additional parameters can be added on new lines. We encourage the reader to check out each of the relevant docstrings (see `kcwi/py/kcwi.py`) for more details and implementation strategies. We outline the basic parameters below:

**General Parameters:**
`dimension x y`: final cube x and y dimensions
`orientation deg`: final cube position angle (degrees east of north; 0 corresponds to north up, east left)
`xpix` and `ypix` are the pixel scales in units of arcsec/pix

**`kcwi_align` Parameters**:
`align_box x_lower_left y_lower_left x_upper_right y_upper_right`: sets up an alignment box in the `kcwi_align` stage used to cross-correlate each frame and align on a point source common to all frames. Details on constructing this box are discussed in the `kcwi_align` section.

**`kcwi_astrometry` Parameters**:
`ref_xy x y`: the coordinates of the reference object in the stacked cube
`ref_ad RA Dec`: the physical coordinates (in degrees) of the reference object in the reference image (`ref_fn`). 
`ref_fn path`: the full path to the reference (finder) image used to correct the cube's WCS.

## A `jupyter` notebook

A `jupyter` notebook can be used to display the stacking (text) outputs and several diagnostic plots for each stage. A sample notebook is provided [here](../examples/q2343-BX610.ipynb).


# Running the procedures

In the `jupyter` notebook, or a `Python` script.

1. Import the package.

    ```python
    from kcwikit.kcwi import kcwi
    ```

2. Specify the list file for convenience. 

    ```python
    fn = 'target.list'
    ```

3. Pre-alignment setup. 

    ```python
    kcwi.kcwi_align(fn, noalign=True)
    ```

    This procedure will create a quick-look cube (stored at `kcwi_align/target.thum0.fits`) to help set up the alignment box. The `thum0` file is a multi-extension cube with a whitelight (wavelength averaged) image of each constituent cube on each extension. The wavelength range used to make each whitelight image can be adjusted using the `wavebin` argument. At this stage, one can see if the trimming has done its job or if further edge pixel mitigation might be required, and one can (hopefully!) see their target in each one of the images. The X and Y pixel locations also correspond to the `align_box` parameter in the parameter file. Adjust the trimming and alignment boxes if needed. 

    If there is a nearby point source that can be picked up in all of the cubes, that is the target around which to draw the alignment box; otherwise, one could use the cube target (assumed here to be an extended source) as a backup at the cost of some alignment accuracy.

    The `thum0` file places each frame on the same final grid and the goal is to find a box large enough that the alignment source (or at least the brightest part of it) is within the box in all images. Once such a box is constructed, the coordinates should be fed into the `align_box` argument of the `.par` file. 

4. Running the alignment procedure. 

    ```python
    kcwi.kcwi_align(fn)
    ```

    This function performs cross correlation on the white-light images within the alignment box. For each cube, a diagnostic plot should be displayed roughly centered on the alignment source, plus a smaller subgrid aligmnet box and cross, all centered on the brightest part of the target. If this is not the case, the alignment has failed for that object. 
    
    Another check can be conducted with the `kcwi_align/*.thum.fits` file. Like the `thum0` file, it is a compiled cube containing white-light images in each layer, but are after the alignment. In other words, objects should appear at the exact same pixel location in each layer. 

    <details>
    <summary>Trouble shooting </summary>

    - The alignment box is misaligned or not well positioned, reposition the box, expanding/contracting as required.
    - If the object is at the edge of the search box for a few of the frames, one can adjust the `search_size` parameter from 10 (default) to 20 pixels (i.e. `kcwi_align(fn, search_size=20)`).
    - Sometimes, if the field contains multiple point sources, the alignment may be confused and aligned on the wrong target. If this happens, set up a pre-shift file.  

        `target.pre.list`:
        ```
        kb210415_00060 -1.8 0
        kb210415_00061 -1.8 0
        kb210705_00030 -1.5 -1.5
        kb210705_00031 -4.0 0.0
        kb210705_00032 -4.0 -3.0
        kb210706_00049 1 -1
        ```
        Similar in format to the `.list` file, in this case only the affected frames are listed and the latter two columns show the x and y shift _in arcseconds_ respectively. For example, if frame 60 needs to be moved 10 pixels up with respect to the first (fiducial) frame, and the pixel scale (`ypix`) was 0.3"/pixel, the appropriate line item would be `kb210415_00060 0 3`. A similar calculation would be required for any horizontal translation. Rerun the `kcwi.kcwi_align(fn, noalign=True)`, and check the new `thum0` file to make sure the pre-shifts are registered correctly. 
    - The initial WCS of some frames may be very off. For these frames, set the pre-shift file to bring them back to a relatively consistent position to other frames. See the above bullet point for details. 
    - If the target is very diffuse, some background subtract may be needed to bring out the more compact features. Run `kcwi.kcwi_align(fn, background_subtraction=True, background_level=0.3)`, where `background_level` is the number subtracted from the white-light images.
    </details>

5. (optional) `kcwi_check_flux` and `kcwi_norm_flux`

    If a few of your exposures were through clouds or underwent other throughput variations, you can normalize the overall flux to other frames to increase the flux-calibration accuracy. 

    Running `kcwi.kcwi_check_flux(fn)` will output a plot of each frame's flux relative to the first. The user can take note of which frames appear significantly lower from the others and input that list into `kcwi_norm_flux`.

    For instance, if frames 2, 5, and 7 had a significant loss in flux due to cloud cover, the user can run `kcwi.kcwi_norm_flux(fn, frame=[2,5,7])` and this function will generate a `<object_name>.flx.list` file that will show the necessary multiplicative flux correction required for each frame. The `kcwi_stack` function (see below) will read this file in by default and make the appropriate corrections during stacking.

6. Stacking. 

    ```python
    kcwi_stack(fn)
    ```

    The `kcwi_stack` function converts the aligned cubes into a format readable by `Montage` and stacks them. If alignment was successful, this stage should generally run on rails and a `tqdm` progress bar provides some eye candy. This step generally takes several minutes on a decent system, obviously dependent on the number of exposures.

    Some pertinent flags for this stage are enumerated below.

    `cubed`: set to `True` to use `*icubed.fits` files instead of the default `*icubes.fits`, this is mostly useful for quick reductions during the night.

    `drizzle`: set the drizzle factor. Default is 0.7, which is balanced between recovering some spatial resolution vs. increasing artifacts. For the large slicers in particular, because the native spatial sampling is too rectangular, one may want `drizzle=0.9` to reduce the amount of artifacts.
    
    `overwrite`: overwrite any previous files
    
    `montagepy`: whether to use the Python or command-line version of Montage. The package should be able to detect which version can be used, but in case it fails, this can be mannually set. 
    
    `npix_trim`: the number of pixels to trim from the side of a cube. Default is 3, may require more or less depending on slicer/binning.

    The **output** of this stage should be four cubes:
    - `<object_name>_icubes.fits` - stacked cube
    - `<object_name>_vcubes.fits` - stacked variance cube
    - `<object_name>_mcubes.fits` - stacked `MASK` and `FLAGS` cube (concatenated)
    - `<object_name>_ecubes.fits` - stacked exposure time cube; masked pixels not included in the total exposure time

7. (Optional) Astrometry.

    ```python
    kcwi.kcwi_astrometry(fn)
    ```

    The `kcwi_astrometry` function updates the final stacked cube's WCS information based on an external reference image. For extragalactic targets, NED optical band finder charts, panstarrs finder charts, or HST images tend to work well for this sort of thing. 

    To find the center of your object in the cube, one can use `QFitsView` and the `g` key for a rough estimate. Those coordinates get fed into `ref_xy`, and the physical coordinates (in degrees) of the same target in the reference image (`ref_fn`) become `ref_ad` in the parameter file. 

    With `ref_xy`, `ref_ad`, and `ref_fn` set we can proceed with running `kcwi_astrometry(fn)`. Two rounds of cross-correlations are run and the output diagnostic plot should appear similar to those of `kcwi_align`. 

    Note: if you'd prefer to just change the WCS information without doing a full cross-correlation (this is sometimes useful for QSOs), you can add `ref_nocrl 1` to the parameter file. 

    The **output** WCS-corrected cube will appear in the working directory as `<object_name>_icubes_wcs.fits`.


# Q & A

- I need my blue and red channel cubes to be projected on the same pixel grid after the astrometry correction. How to do that? 

    A: There is an ad hoc solution for this, but requires to run the stacking code twice. Run all the processes until after `kcwi_stack`. For astrometry, run `kcwi.kcwi_astrometry(fn, save_shift=True)`. It will create a `astrom.list` file that stores the astrometry correction. Set `stack_ad <RA> <Dec>` in the parameter file to indicate the center of the desired grid. Rerun `kcwi.kcwi_stack(fn, use_astrom=True, overwrite=True)`. The newly generated `*_icubes_wcs.fits` will be created on the new grid. 

- I did not rotate the field, or perform sub-slice dithering during the observations. The pixels in the newly projected data cubes look artificial and boxy. What can I do? 

    A: We recommend to always (maybe except for the small slicer) perform sub-slice dithering, or rotation to the FoV to improve the spatial sampling (see [Chen+21](https://ui.adsabs.harvard.edu/abs/2021MNRAS.508...19C/abstract)). If you did not do this in your observation, the best fix may be using cubic or linear interpolations, instead of the drizzle algorithm. When stacking, run `kcwi.kcwi_stack(fn, method='bicubic')` or `kcwi.kcwi_stack(fn, method='bilinear')`.

- My computer ran out of memory space when stacking the small slicer data. 

    A: Use `kcwi_stack(fn, lowmem=True)`. This will significantly increase the amount of time to run the stacking code, but reduces the memory consumption by not loading all the individual frames at once. 


